\documentclass[10pt]{beamer}
\input{lecture_preamble.tex}

\title{Теория алгоритмов\\Вычислимость}
\date{\today}

\begin{document}
\begin{frame}[plain]
\maketitle
\end{frame}

\begin{frame}
    \frametitle{Алгоритмы и программы}
    \begin{itemize}
        \item Алгоритм задаётся программой на каком-то абстрактном языке программирования.
        \item Язык позволяет работать с натуральными числами произвольной величины.
        \item Или другими объектами, задаваемыми конечными словами в конечном алфавите (элементами какого-то \emph{дискретного множества}).
        \item Не взаимодействует с внешним миром, кроме получения аргумента/ов и возвращения результата.
        \item Не использует случайных чисел и других источников недетерминированности.
        \item Конкретные примеры таких языков в конце лекции.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Функции, вычисляемые алгоритмами}
    \begin{itemize}
        \item Каждый алгоритм (программа) тогда вычисляет какую-то функцию.
        \item Эта функция может быть не везде определена (если алгоритм не останавливается или останавливается, не выдав осмысленного результата).
        \item В этом разделе функции по умолчанию могут быть частичными, всюду определённость оговаривается особо.
        \item Мы говорим в первую очередь о функциях $\mathbb{N} \to \mathbb{N}$, но областями определения и значений могут быть и любые другие дискретные множества.
        \item Разные алгоритмы могут вычислять одну и ту же функцию.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Вычислимые функции}
    \begin{itemize}
        \item Функция \emph{вычислима}, если какой-то алгоритм её вычисляет.
        \item Например, нигде не определённая функция вычислима \pause алгоритмом, который зацикливается на любом входе.
        \pause
        \item Или функция $x \mapsto x^2$. 
        \item Зависит ли это от языка? \pause Скажем, если там нет операции умножения?
        \pause
        \item Есть невычислимые функции $\mathbb{N} \to \mathbb{N}$ \pause просто потому, что всех таких функций \pause $\mathfrak{c}$, а программ и вычислимых функций \pause $\aleph_0$.
        \item Из простых вычислимых функций можно строить более сложные. Например, композиция вычислимых функций вычислима (почему?).
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Разрешимые множества}
    \begin{itemize}
        \item Множество $A \subseteq \mathbb{N}$ \emph{разрешимо}, если есть алгоритм, позволяющий проверить принадлежность к нему любого натурального числа: получает на вход $n$ и выдаёт $1$, если $n \in A$ и $0$, если $n \notin A$. 
        \item То есть вычислима характеристическая функция $\chi_A(n) = $ если $n \in A$ то $1$ иначе $0$ (короче: $\chi_A(n) = n \in A$).
        \pause
        \item Вместо $\N$ можно взять любое дискретное множество.
        \pause
        \item Может быть известно, что множество разрешимо (или что функция вычислима), но неизвестно, как именно. Классический пример: $A = \{n \mid$ в десятичной записи $\pi$ есть $n$ нулей подряд$\}$.
        \pause
        \item Теорема: объединение, пересечение и дополнение разрешимых множеств разрешимы.
        \item Теорема: декартово произведение разрешимых множеств разрешимо (как подмножество $\mathbb{N} \times \mathbb{N}$).
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Перечислимые множества}
    \begin{itemize}
        \item Множество $A \subseteq \mathbb{N}$ \emph{перечислимо}, если есть алгоритм, позволяющий подтвердить принадлежность к нему, но не опровергнуть: получает на вход $n$ и выдаёт $1$, если $n \in A$ и ничего не выдаёт, если $n \notin A$.
        \item То есть вычислима полухарактеристическая функция $\bar{\chi}_A(n) = $ если $n \in A$ то $1$ иначе не определена.
        \item Все следующие утверждения эквивалентны:
        \begin{itemize}
            \item $A$ перечислимо.
            \item $A = \{n : \mathbb{N} \mid f(n)$ определена$\}$ для какой-то вычислимой $f$.
            \item $A = \{f(n) \mid n : \mathbb{N}\}$ для какой-то вычислимой $f$.
            \item Есть алгоритм без входа, перечисляющий элементы $A$.
        \end{itemize}
        \item Теорема: объединение и пересечение перечислимых множеств перечислимы.
        \item Теорема: декартово произведение перечислимых множеств перечислимо.
        \item Теорема: если множество и его дополнение перечислимы, то оно разрешимо.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Универсальные вычислимые функции}
    \begin{itemize}
        \item Пусть есть какое-то множество $X \subseteq \mathbb{N} \to \mathbb{N}$ функций одного аргумента.
        \item Функция двух аргументов $f : \mathbb{N} \times \mathbb{N} \to \mathbb{N}$ называется \emph{универсальной для $X$}, если $X = \{m \mapsto f(n, m) \mid n : \mathbb{N}\}$.
        \item \emph{Универсальная вычислимая функция} это вычислимая функция двух аргументов, универсальная для класса всех вычислимых функций одного аргумента.
        \item Теорема: существует универсальная вычислимая функция.
        \item Доказательство: \pause перенумеруем все программы нашего языка, например, в порядке возрастания длины, а при одинаковой длине по алфавиту: $p_0,p_1,\ldots$ 
        \item Определим $U(n,m) = p_n(m)$ (то есть перечисляем программы, пока не дойдём до $p_n$, и запускаем её на аргументе $m$).
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Универсальные и всюду определённые функции}
    \begin{itemize}
        \item Теорема: не существует всюду определённой вычислимой функции, универсальной для класса всюду определённых вычислимых функций одного аргумента.
        \item Доказательство: предположим, что такая функция есть, и обозначим $V(n,m)$. Определим $V'(n) = V(n,n) + 1$. Она \pause вычислима, \pause всюду определена, и \pause не совпадает ни с одним сечением $V$ (почему?).
        \pause
        \item Почему это доказательство не работает для класса всех вычислимых функций и функции $U$? В каком случае возможно $U' = m \mapsto U(m,m) + 1 = m \mapsto U(n,m)$?
        \pause
        \item Теорема: существует вычислимая функция $f$, не имеющая всюду определённого вычислимого продолжения (функции, совпадающей с $f$ на $Dom\ f$).
        \item Доказательство: \pause это $U'$. Предположим, что $U''$ её в.о.в.п., и придём к противоречию.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Неразрешимость проблемы остановки}
    \begin{itemize}
        \item Теорема: существует перечислимое неразрешимое множество (имеющее неперечислимое дополнение).
        \pause
        \item Доказательство: это $Dom\ U'$. 
        \begin{itemize}
            \item Она перечислима, потому что это \pause область определения вычислимой функции.
            \item Предположим, что она разрешима. Определим
            $U''(n) = \begin{cases*}
                U'(n) & если $U'(n)$ определена, \\
                0 & иначе
            \end{cases*}$
            \pause \\
            Это всюду определённое вычислимое продолжение $U'$ (проверьте). Противоречие!
        \end{itemize}
        \pause
        \item Следствие: $Dom\ U$ неразрешима.
        \item Доказательство: \pause иначе $Dom\ U'$ тоже была бы разрешима.
        \pause
        \item Другими словами, не существует алгоритма, который по произвольной программе $p$ и аргументу $n$ может точно определить, закончится ли вычисление $p(n)$.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Теорема (Успенского--)Райса}
    \begin{itemize}
        \item Свойство программ $P$ называется \emph{семантическим}, если оно определяется только функцией, которую вычисляет программа.
        \begin{itemize}
            \item То есть если две программы $p_1$ и $p_2$ обе вычисляют одну и ту же функцию, то $P(p_1) \Leftrightarrow P(p_2)$.
            \pause
            \item Например, \enquote{Программа останавливается на любых входных данных} это \pause семантическое свойство.
            \item А \enquote{длина программы больше 100 символов} \pause нет.
        \end{itemize}
        \pause
        \item Свойство нетривиально, если оно истинно для некоторых программ и ложно для других.
        \item Теорема Райса: любое семантическое нетривиальное свойство программ неразрешимо.
        \pause
        \item Проблема остановки это частный случай: свойство \enquote{программа $p$ даёт результат при запуске с аргументом $0$} семантическое и нетривиальное.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Простые модели вычислений}
    \begin{itemize}
        \item Мы пока почти ничего не говорили про конкретные языки.
        \item Для доказательств часто оказывается удобно работать не с привычными C, Python и т.д., а со специальными простыми языками.
        \item Особенно при доказательстве неразрешимости каких-то задач или невычислимости каких-то функций \pause (первое это частный случай второго).
        \item Чаще всего это делается сведением задачи к проблеме остановки (или к другой задаче, для которой уже доказали неразрешимость).
        \item То есть показывается, что мы можем \enquote{эмулировать} произвольную программу на нашем языке в терминах этой задачи так, чтобы решение задачи позволило сказать, остановится программа или нет.
        \item А это проще, если язык небольшой и программы на нём устроены просто.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Регистровая машина}
    \begin{itemize}
        \item Программа регистровой машины состоит из конечной пронумерованной последовательности команд следующих видов:
        \begin{itemize}
            \item (переменная) $:=$ 0
            \item (переменная1) $:=$ (переменная2)
            \item inc(переменная) (добавить $1$)
            \item dec(переменная) (вычесть $1$, если текущее значение положительное)
            \item if (переменная)=0 goto (номер команды)
            \item stop
        \end{itemize}
        \item Каждая такая программа очевидно использует конечное число переменных (или регистров).
        \item Значения переменных "--- натуральные числа, в начале все $0$.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Вычисление функций на регистровой машине}
    \begin{itemize}
        \item Каждая такая программа вычисляет определённую функцию.
        \item Пусть среди переменных программы есть $i_1, \ldots, i_n$ и нет $i_{n+1}$, тогда у функции $n$ аргументов.
        \item Поместим в переменные $i_1, \ldots, i_n$ значения аргументов функции.
        \item Начнём выполнять команды начиная с первой, если команда не goto, переходим к следующей.
        \item Если мы дойдём до конца программы или выполним команду stop, то значение функции это содержимое переменной $o$ на этом шаге.
        \item Если ни того, ни другого не произойдёт, то функция на этих аргументах не определена.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Языки BlooP и FlooP}
    \begin{itemize}
        \item Язык BlooP (Bounded Loop):
        \begin{itemize}
            \item Регистровая машина без команды goto.
            \item Добавляются ограниченные по числу повторений циклы с break и continue.
            \item И именованные функции без рекурсии.
            \item В обычном описании есть $+$, $\cdot$, $<$, $==$ и нет inc и dec, но это не существенно.
        \end{itemize}
        \pause
        \item Как в обычной регистровой машине получить аналог именованных функций?
        \pause
        \item Язык FlooP (Free Loop):
        \begin{itemize}
            \item BlooP + неограниченные циклы (while(true)).
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Примитивно и частично рекурсивные функции}
    \begin{itemize}
        \item Примитивно рекурсивные функции это те, которые можно получить из базовых функций с помощью операторов композиции и примитивной рекурсии:
        \begin{itemize}
            \item Базовые функции: $O(x) = 0$, $S(x) = x+1$, $I_n^i(x_1, \ldots, x_n) = x_i$.
            \item Композиция: пусть $f$ функция $m$ аргументов, $g_1, \ldots, g_m$ функции $k$ аргументов, тогда $C(f, g_1, \ldots, g_m) = h$, где \\ $h(x_1, \ldots, x_k) = f(g_1(x_1, \ldots, x_k), \ldots, g_m(x_1, \ldots, x_k))$.
            \item Примитивная рекурсия: пусть $f$ функция $n$ аргументов, $g$ функция $n+2$ аргументов, тогда $R(f,g)=h$, где \\
            $h(x_1, \ldots, x_m,0) = f(x_1, \ldots, x_m)$, \\
            $h(x_1, \ldots, x_m,y+1) = g(x_1, \ldots, x_m, y, h(x_1, \ldots, x_m, y))$.
        \end{itemize}
        \pause
        \item Частично рекурсивные функции получаются, если добавить оператор минимизации:
        \begin{itemize}
            \item Пусть $f$ функция $n+1$ аргумента, тогда $\mu(f)(x_1, \ldots, x_n)$ считается так: вычисляем $f(x_1, \ldots, x_n, y)$, начиная с $y=0$. Если получили $0$, возвращаем $y$. Если нет, то увеличиваем $y$ на $1$ и повторяем.
            \item В каких случаях этот процесс не остановится?
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Связь между моделями вычислений}
    \begin{itemize}
        \item Очевидно ли, что все ПРФ и ЧРФ вычислимы?
        \pause
        \item Оказывается (без доказательства):
        \item Любая программа на BlooP задаёт ПРФ.
        \item И наоборот, любая ПРФ задаётся программой BlooP.
        \pause
        \item Аналогично для FlooP и ЧРФ.
        \item И для регистровых машин и ЧРФ.
        \begin{itemize}
            \item Даже если ограничиться командами inc, dec и if-goto, этого достаточно для задания всех ЧРФ.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Тезис Чёрча--Тьюринга}
    \begin{itemize}
        \item А есть ли вычислимые функции, которые не являются ЧРФ?
        \pause
        \item Тезис Чёрча--Тьюринга: любая функция, которую можно вычислить каким угодно алгоритмом, частично рекурсивна.
        \item И значит, любую такую функцию можно задать программой на FlooP и регистровой машиной.
        \pause
        \item При разумных ограничениях понятия алгоритма это можно доказать. И никто не придумал алгоритм, который под них не подпадает.
        \pause
        \item Кроме того, есть лямбда-исчисление, машины Тьюринга, машины Поста, алгоритмы Маркова и т.д.
        \item Оказывается, что в этих моделях тоже можно вычислить любую ЧРФ (и только ЧРФ).
        \item Такие модели вычислений называются полными по Тьюрингу.
    \end{itemize}
\end{frame}

\end{document}
